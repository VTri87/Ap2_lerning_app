{"exams":[{"id":"winter_2021_22_teil2","season":"Winter","year":"2021/22","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Winter 2021/22 – Teil 2","tasks":[{"num":1,"points":25,"content":"Sie erhalten den Auftrag die „Online-Terminvergabe\" grundlegend zu planen. Dazu wurden zwei unterschiedliche Vorgehenswei­sen grob vorgeplant.\nDiese sind in der Tabelle „Ablauf\" mit Variante 1 und Variante 2 dargestellt.\na)\nStellen Sie den Ablauf der Variante 1 mit einem UML-Aktivitätsdiagramm dar.\nAblauf:\nPatient ruft die Terminreservierung auf, wonach er eine Anzeige der Ärzte und Terminarten erhält. Jetzt kann er den Arzt bzw. die Terminart\nauswählen.\nNach der Auswahl sucht die Software den 1. freien Termin ....\nVariante 1:\nVariante 2:\n… Das Programm zeigt den Monat, in dem der 1. freie Termin liegt,\nmit allen freien Terminen im angezeigten Zeitraum an. Der\nAnwender wählt einen freien Termin.\nDas System versucht nun, den Termin zu blockieren.\nWenn der Termin noch frei ist, kann er final reserviert und parallel\ndazu der Anwender informiert werden. Danach ist die Aktivität\nbeendet.\nIst der Termin inzwischen nicht mehr verfügbar, wird eine\nentsprechende Meldung ausgeben und erneut der 1. freie Termin\ngesucht, um dem Anwender die Auswahl anzuzeigen.\n... Die Software ermittelt den Monat des 1. freien Termins . Es\nwerden alle Termine des ermittelten Monats blockiert. Der Monat\nmit allen freien Terminen wird zur Auswahl angezeigt.\nDer Anwender kann einen freien Termin wählen.\nDanach wird der Anwender bzgl. der erfolgreichen Reservierung\ninformiert und parallel der Termin final reserviert sowie alle\nanderen blockierten Termine freigegeben.\nDanach ist die Aktivität beendet.\nUML-Aktivitätsdiagramm:\nAnwender\nTerminvergabesystem\nFortsetzung 1. Aufgabe\nb)\nWählen Sie für die zu erstellende Terminvergabe eine Variante aus und begründen Sie Ihre Wahl in Hinblick auf die Praxistauglichkeit.\n(4 Punkte)\nc)\nDie Online-Terminvergabe soll nur über einen Login möglich sein. Dazu müssen die Benutzer einen Account erstellen und ein Passwort\nvergeben, welches folgende Kriterien erfüllen muss:\n-\nEs muss mindestens zehn Zeichen lang sein.\n-\nEs muss mindestens einen Buchstaben (letter), eine Ziffer (digit) und ein Sonderzeichen (specialChar) enthalten.\nEs liegt ein fehlerhaftes Struktogramm zur Überprüfung des Passwortes vor. Der Rückgabewert soll wahr oder falsch sein.\nFinden Sie drei Fehler und geben Sie eine Korrektur an.\n(6 Punkte)"},{"num":2,"points":25,"content":"Für eine Gemeinschaftspraxis, der mehrere Ärzte angehören, soll für die Sprechstundenhilfen eine softwaregestützte Terminpla­nung realisiert\nwerden.\nBenötigt wird dazu eine Funktion, die unter Vorgabe eines Datums (Tag und Monat), einer Ärzte-lD und eines Zeitslots ermittelt, ob unter diesen\nVorgaben ein Termin möglich ist.\nFür jeden Arzt liegt ein Terminplan in Form eines zweidimensionalen Arrays vor. Jede Zeile dieses Arrays speichert für einen Tag die Belegung von acht\nmöglichen Zeitslots für diesen Arzt.\nBeispiel:\nMonat\nTag\nSlot 1\nSlot 2\nSlot 3\nSlot 4\nSlot 5\nSlot 6\nSlot 7\n…\n9\n30\n1\n1\n0\n0\n1\n1\n1\n10\n1\n0\n0\n1\n1\n0\n0\n1\n10\n2\n0\n0\n0\n1\n1\n1\n1\n…\n(1 -Arzt in diesem Zeitslot belegt, 0 -Arzt in diesem Slot nicht belegt)\nFür den Zugriff auf das zweidimensionale Array eines Arztes liegt folgende Funktion bereits vor:\ngetTimeTable (id : Integer) : 2-dim-lnteger-Array\nLiefert für eine übergebene Ärzte-lD den zugehörigen Terminplan als zweidimensionales Array\n(siehe Beispiel)\nEs soll folgende Funktion erstellt werden:\ngetAppointment(month: Integer, day: Integer, id : Integer, slot: Integer) : Boolean\n-\nFalls kein bestimmter Zeitslot ausgewählt werden muss, hat der Parameter „slot\" den Wert -1.\n-\nDie Funktion getAppointment soll den Wert true zurückgeben, falls ein Termin gefunden werden kann, andernfalls den Wert false.\nErstellen Sie auf der gegenüberliegenden Seite diese Funktion getAppointment in Pseudocode.\ngetAppointment(month: Integer, day: IntegerQ, id : Integer, slot: Integer)Q : boolean"},{"num":3,"points":25,"content":"Ein Kollege von Ihnen hatte begonnen, das relationale Modell der bestehenden Datenbank zu erweitern. Krankheitsbedingt fällt er leider nun einige\nWochen aus und Sie übernehmen seine Aufgaben. Zunächst sollen Sie das relationale Datenmodell fertigstellen. Dazu stehen Ihnen die\nnachfolgenden Unterlagen zur Verfügung. In diesen sind exemplarische Daten für Untersuchungstermine und Patientendiagnosen enthalten. Diese\nDaten sollen in der Datenbank verwaltet werden.\nUntersuchungstermine\nUTNr\nDatum/Uhrzeit\nPatient\nArzt\nRaum\n1\n20.04.2021 - 10.00 Uhr\nSommer, Hans\nHohlweg 17, 55555 Bergtal\nBaum, Walter\nRöntgenraum 2\n2\n20.04.2021 - 11.00 Uhr\nReins, Fraucke\nWinzergasse 5, 55555 Bergtal\nBaum, Walter\nRöntgenraum\n1\n3\n21.04.2021 - 10.00 Uhr\nFuchs, Katrin\nBachweg 12, 55554 Zweigtal\nWinter, Simone\nMRT\nPatientendiagnose\nPDNr\nDatum\nPatient\nArzt\nICD_10_GM_Code\nBermerkungen\n1\n23.04.2021\nSommer, Hans\nBaum, Walter\nM71\nWiedervorstellung in 3 Monaten\n2\n07.06.2021\nReins, Fraucke\nFrühling, Klaus\nK93\n3\n22.06.2021\nFuchs, Katrin\nWinter, Simone\nD50\nÜberweisung an einen Spezialisten\nHinweis: Die Untersuchungstermine und die Patientendiagnose sind voneinander unabhängig. Die Diagnose kann auch ein ande­rer Arzt als der\nuntersuchende Arzt erstellen.\nErweitern Sie das relationale Datenmodell auf Seite 7 um die notwendigen Tabellen mit den entsprechenden Attributen in der 3. NF. Zeichnen Sie die\nBeziehungen zwischen den Tabellen ein und bestimmen Sie die Kardinalitäten. Kennzeichnen Sie in allen Tabellen die Primär- und Fremdschlüssel\nmit PK bzw. FK.\nRelationales Modell:\nDiagnose\nDiagnoselD (PK)\nICD_ 10_GM_Code\nKurzbeschreibung\nAufgabe\n(25 Punkte)\nDie Arzneimittel mit deren Wirkstoffen sind in folgender Datenbank erfasst.\nHinweis: Das Attribut „rezeptpflichtig\" hat den Datentyp Boolean. Die Überschriften müssen nicht per Alias angepasst werden. Erstellen Sie für die\nnachfolgenden Aufgabenstellungen die entsprechenden SQL-Anweisungen.\na)\nLegen Sie die Tabelle „ Hersteller\" an.\n(3 Punkte)\nb)\nZeigen Sie an, ob das Arzneimittel mit der Bezeichnung „abc'' rezeptpflichtig ist.\n(3 Punkte)\nc)\nErhöhen Sie den Preis aller Arzneimittel vom Hersteller „CCC\" um fünf Prozent.\n(5 Punkte)\nd)\nListen Sie alle Hersteller auf, von denen mehr als 50 nichtrezeptpflichtige Arzneimittel in der Datenbank erfasst sind. Die Ausgabe soll\nfolgende Daten auflisten.\n(6 Punkte)\nBeispiel:\nHersteller\nAnzahl\nABC\n234\nDDDD\n96\nXXX\n51\ne)\nListen Sie die Bezeichnung, die Menge, den Preis und den Hersteller aller Arzneimittel auf, welche den Wirkstoff„ Y34\" in der Menge von\n100 oder 200 Einheiten enthalten. Das Ergebnis soll absteigend nach der Menge und dann aufsteigend nach dem Preis sortiert sein.\n(8 Punkte)\nBeispiel:\nBezeichnung\nMenge\nPreis\nHersteller\nAY34-200\n200\n13,67\nAAA\nBB Y34\n200\n15,88\nBBB\nAY34-100\n100\n8,55\nAAA\nCC XX 100\n100\n9,99\nCCC\nLösungshinweise Winter 2021/22 Teil 2 - Entwicklung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\na)\nDas UML-Aktivitätsdiagramm muss immer über einen Startknoten begonnen und mittels eines Endknoten been­det werden.\nAn Entscheidungen müssen Bedingungen anliegen, bei Zusammenführungen darf es keine Bedingungen geben. Sollten Bedingungen\nerforderlich sein, so müssen diese immer in eckigen Klammern notiert werden.\nGemäß Angabe muss eine Parallelisierung von Prozessschritten stattfinden. Die hierfür erforderliche Teilung {Split­ting) sowie die\nanschließende Synchronisation sind im Diagramm zu berücksichtigen.\nZwischen Aktivitäten und Aktionen ist nicht zu unterscheiden und Pins sind ebenfalls nicht erforderlich.\nb)\nEs ist Variante 1 zu wählen. Da häufig von parallelen Zugriffen auszugehen ist, ist Variante 2 nicht praktikabel. Alle Termine des ermittelten\nMonats würden hier direkt blockiert und dem Anwender zur Auswahl gestellt werden. Je nach Dauer des Reservierungsprozesses sind alle\nTermine für parallel angemeldete Patienten blockiert. Dies führt zu Irritationen und ggf. telefonischen Rückfragen.\nc)\n1. Fehler:\n-\nStelle: Erste Verzweigungsbedingung\n-\nIST-Zustand: Bedingung: password.length > 10\n-\nKorrektur: Bedingung: password.length > 10\n2.Fehler:\n-\nStelle: Schleifenbedingung while / solange\n-\nIST-Zustand: Bedingung: i < password.length\n-\nKorrektur: Bedingung: i < password.length\n3.Fehler:\n-\nStelle: Erste Anweisung innerhalb des Nein-Zweiges zu isDigit(password[i]) = true\n-\nIST-Zustand: digit := false\n-\nKorrektur: Anweisung muss gestrichen werden\n4.Fehler:\n-\nStelle: Ende des Struktogramms\n-\nIST-Zustand: Keine Ausgabe des passwordOK-Wertes\n-\nKorrektur: Return passwordOK als letzte Anweisung\n2.\nAufgabe Lösung\ngetAppointment(month: Integer, day: Integer, id: Integer, time_slot: Integer) : Boolean\nboolean treffer = false\nint[] [] timeTableOoc = getTimeTable(id)\nfür· i = O, i < timeTableDoc.length\nwenn (month == timeTableDoc[i] [0] &&\nday == timeTableDoc[i] [1])\nwenn (time_slot < 0)\nfür z = O; z < 8\nwenn (timeTableDoc[i] [2 + z] == 0)\ntreffer = true\nende wenn\nende für\nsonst\nwenn (timeTableDoc[i] [2 + time_slot] == 0)\ntreffer = true\nende wenn\nende wenn\nende wenn\nende für\nRückgabe treffer;\nende getAppointment\n3.\nAufgabe Lösung\nBzgl. Der Kardinalitäten ist drauf zu achten, dass M:N Beziehungen aufgelöst werden. Pro Relation darf immer nur ein Primärschlüssel\nverwendet werden.\n4.\nAufgabe Lösung\na)\nCREATE TABLE Hersteller (HerstellerlD INT, Name VARCHAR(30), PRIMARY KEY (HerstellerlD));\nb)\nSELECT rezeptpflichtig FROM Arzneimittel WHERE Bezeichnung = \"abc\";\nc)\nUPDATE Arzneimittel SET Preis = Preis* 1.05\nWHERE HerstellerlD = (SELECT HerstellerlD FROM Hersteller WHERE Bezeichnung = \"CCC\");\nd)\nSELECT H.Name, COUNT (A.ArzneimittellD)\nFROM Arzneimittel AS A, Hersteller As· H\nWHERE A.HerstellerlD = H.HerstellerlD AND rezeptpflichtig = False\nGROUP BY H.Name HAVING COUNT (A.ArzneimittellD) > 50;\ne)\nSELECT A.Bezeichnung, AW.Menge, A.Preis, H.Name\nFROM Wirkstoff AS W, Arzneimittelwirkstoffe AS AW, Arzneimittel AS A, Hersteller AS H\nWHERE W.WirkstofflD = AW.WirkstofflD AND\nAW.AMID = A.AMID AND\nA.HerstellerlD = H.HerstellerlD AND\nW.Bezeichnung = \"Y34\" AND (AW.Menge = 100 OR AW.Menge = 200)\nORDER BY A W.Menge DESC, A.Preis ASC;"}]},{"id":"sommer_2022_teil2","season":"Sommer","year":"2022","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Sommer 2022 – Teil 2","tasks":[{"num":1,"points":30,"content":"Für eine Statistik sollen die Energieverbräuche des jeweils letzten Jahres ausgewertet werden. Die Zählerstände zu jedem Mo­natsende eines Jahres\nliegen für alle Verbraucher in Zweipersonenhaushalten in einem zweidimensionalen Array verbrauch vor. In der Spalte O des Arrays ist die\nVerbrauchernummer und in der Spalte 1 der Zählerstand von Ende Dezember des Vorjahres eingetragen. Alle anderen Spalten enthalten die\nZählerstände der einzelnen Monate des auszuwertenden Jahres. Die Zeile 0 enthält die Daten des ersten Verbrauchers.\nBeispiel:\nFür die Auswertung der Daten werden folgende statistische Werte benötigt:\n-\nMinimaler Monatsverbrauch über alle Verbraucher hinweg\n-\nMaximaler Monatsverbrauch über alle Verbraucher hinweg\n-\nFür jeden Verbraucher, der in einem Monat einen vorgegebenen Schwellenwert (limit) überschritten hat, sind folgende Informationen in\neinem Objekt der Klasse Monatsverbrauch zu speichern:\ndie VerbraucherNr, die Monatsnummer (1 für Januar, ... , 12 für Dezember), der Verbrauch\nDieses Objekt wird anschließend einer Liste hinzugefügt.\nDas zweidimensionale Array verbrauch steht innerhalb der Methode zur Verfügung, ebenso eine Variable limit, welche den vorgegebenen\nSchwellenwert enthält. Die Anzahl der Datensätze des Arrays kann durch verbrauch.length bestimmt werden. Für ein List-Objekt stehen folgende\nMethoden zur Verfügung:\nErstellen Sie eine Methode statistik(verbrauch: int [] [], limit: int) zur Auswertung der Verbrauchs­daten, welche alle geforderten\nWerte bestimmt.\nDer Rückgabewert soll ein Objekt vom Typ Jahresstatistik (minVerbrauch: int, maxVerbrauch: int, limitVerbraucher: List) sein.\nGeben Sie Ihre Lösung in Pseudocode, als Struktogramm, als Programmablaufplan oder als UML-Aktivitätsdiagramm an."},{"num":2,"points":20,"content":"a)\nZum Testen der Methoden der zu entwickelnden Software kommen Unit-Tests zum Einsatz.\naa) Beschreiben Sie, was ein Unit-Test ist und wozu er verwendet wird.\n(3 Punkte)\nab) Nennen und beschreiben Sie zwei Eigenschaften, welche ein Unit-Test erfüllen sollte.\n(4 Punkte)\nb)\nIm Rahmen des Projektes wurde eine Methode entwickelt, welche folgende funktionalen Anforderungen erfüllen soll:\n-\nDie  Methode soll die positive Differenz zwischen einem alten und einem neuen Zählerstand, welche als Parameter überge­ben\nwerden, berechnen und diesen Wert zurückgeben.\n-\nDie Differenz soll nur dann berechnet werden, wenn die übergebenen Werte nicht negativ sind und der alte Zählerstand nicht größer\nals der neue Zählerstand ist. Ansonsten soll die Methode den Wert -1 zurückgeben.\nQuellcode der Funktion:\nba) Zum Testen der Methode wurde folgender Unittest entwickelt.\nÜberprüfen Sie, ob der Unit-Test erfolgreich ist oder fehlschlägt. Tragen Sie dazu das Ergebnis von jedem Testfall in die Tabelle ein. (OK -\nwenn der Test erfolgreich ist, Fehler - wenn der Test fehlschlägt.)\n(5 Punkte)\nTestfall\nErgebnis des Tests\n1\n2\n3\n4\n5\nbb) Der Unit-Test schlägt fehl.\nPassen Sie den Quellcode so an, dass der Unit-Test erfolgreich durchlaufen wird.\n(4 Punkte)\nint berechneDifferenz (int zaehlerstandAlt, int zaehlerstand.Neu) {\nint differenz -1;\nif (zaehlerstandAlt >= 0 && zaehlerstand.Neu > 0) {\nif (zaehlerstandAlt < zaehlerstand.Neu) {\ndifferenz zaehlerstand.Neu - zaehlerstandAlt;\n}\n}\nreturn differenz;\n}\nbc) Im Unit-Test fehlen noch wichtige Testfälle.\nGeben Sie Testdaten aus zwei weiteren Äquivalenzklassen an, für welche die Methode den Rückgabewert -1 liefern sollte.\n(4 Punkte)\nNr.\nzaehlerstandAlt\nzaehlerstandNeu\ndifferenz\n1\n2"},{"num":3,"points":20,"content":"Die notwendigen Daten für eine Tarifübersicht sollen in einer relationalen Datenbank erfasst werden. Eine Tarifübersicht für ein Jahr sieht wie folgt\naus:\nHinweise: Der in der Übersicht genannte Ansprechpartner ist der persönliche Ansprechpartner des Kunden beim Energieversorger. Das\nAusstellungsdatum wird in der Datenbank nicht erfasst.\nErstellen Sie das entsprechende Datenbankmodell in der 3. Normalform.\n-\nGeben Sie alle erforderlichen Tabellen und die entsprechenden Attribute an.\n-\nKennzeichnen Sie Primärschlüssel mit PK und Fremdschlüssel mit FK.\n-\nZeichnen Sie die Beziehungen zwischen den Tabellen mit deren Kardinalitäten ein."},{"num":4,"points":30,"content":"Für die Verwaltung und Auswertung der Daten soll die Datenbankabfragesprache SQL zum Einsatz kommen.\na)\nIn einer Teambesprechung wurde beschlossen, dass u. a. auch Stored Procedures, Trigger und Indizes verwendet werden.\naa) Beschreiben Sie, was Sie unter dem Begriff „Stored Procedure\" verstehen.\n(2 Punkte)\nab) Beschreiben Sie, was ein Trigger ist.\n(2 Punkte)\nac) Beschreiben Sie, wozu Spalten in Tabellen indiziert werden.\n(2 Punkte)\nb)\nIm Zuge der Datenbankentwicklung wurden u. a. folgende Tabellen entwickelt.\nZur Abfrage und Pflege der Daten sollen nachfolgende SQL-Anweisungen erstellt werden.\nba) Indizieren Sie in der Tabelle Zaehlerstand das Feld ZSt_Datum. Der Index soll die Bezeichnung ldx_Datum bekommen.\n(3 Punkte)\nbb) Löschen Sie alle Haushalte, bei denen kein Zähler hinterlegt wurde.\n(5 Punkte)\nbc) Erstellen Sie eine SQL-Abfrage, mit der Sie alle Haushalte mit der Anzahl der vorhandenen Zähler erhalten. Haushalte mit den\nwenigsten Zählern sollen unten aufgeführt werden.\n(6 Punkte)\nHinweis: Beachten Sie die Spaltenbezeichnungen.\nBeispiel-Ergebnistabelle:\nFortsetzung 4. Aufgabe\nbd) Erstellen Sie eine SQL-Abfrage, mit der Sie die Haushalte mit den vorhandenen Zählern und dem jeweiligen Verbrauch zwischen den\nbeiden Ablesungen in den Jahren 2021 und 2022 erhalten. Die Ergebnisse sollen nach Nachnamen sortiert werden. Es findet pro Jahr nur\neine Eintragung statt.\n(10 Punkte)\nHinweis: Beachten Sie die Spaltenbezeichnungen.\nBeispiel-Ergebnistabelle:\nLösungshinweise Sommer 2022 Teil 2 - Entwicklung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\nNachfolgend finden Sie ein Lösungsbeispiel als Pseudocode.\nWeitere Lösungen in anderen Formen sind möglich.\nJahresstatistik statistik(Verbrauch: int [][], limit:int)\n{\nint min Monat= lnteger.MAX_VALUE;\nint maxMonat = lnteger.MIN_VALUE;\nList<Monatsverbrauch> greaterLimit = new List<Monatsverbrauch>();\nfor (int vn = 0; vn < verbrauch.length; vn++)\n{\nfor (int m = 1; m <= 12; m++)\n{\nint v = verbrauch[vn][m+1] - verbrauch[vn][m];\nif (v > limit)\n{\ngreaterlimit.add(new Monatsverbrauch( verbrauch [vn][0], m, v));\n}\nif (v < min Monat)\n{\nmin Monat= v;\n}\nelse if (v > maxMonat)\n{\nmaxMonat =v;\n}\n}\n}\nreturn new Jahresstatistik (min Monat, maxMonat, greaterLimit);\n}\n2.\nAufgabe Lösung\naa)\nUnit-Tests können auch als Komponententests bezeichnet werden. Mithilfe dieser Tests wird überprüft, ob alle Einzel-Komponenten\n{Units) so funktionieren, wie dies beabsichtigt war. Unit-Tests sind voneinander unabhängig und isoliert, ein fehlgeschlagener Unit-Test\ndarf deshalb nicht zu weiteren Fehlern in anderen Units führen. Außerdem sind gute Unit-Tests um eine sogenannte Test Fixture gruppiert\nund nicht um eine Klasse.\nab)\nUnit-Tests folgenden F.I.R.S.T.-Prinzipien:\n-\nFast: Die Ausführung der einzelnen Tests sollte schnell sein, damit möglichst oft getestet werden kann.\n-\nIndependent: Da Unit-Tests unabhängig voneinander sind, können sie in beliebiger Reihenfolge und Anzahl parallel oder einzeln\nausgeführt werden.\n-\nRepeatable: Unit-Tests müssen mehrfach ausführbar sein, während das Ergebnis jedoch immer gleich sein muss:\n-\nSelf-Validating: Ein Unit-Test unterstützt nur die Status „fehlgeschlagen\" und „erfolgreich\". Der Status muss automatisch gesetzt\nwerden. Eine manuelle Prüfung darf nicht notwendig sein.\n-\nTimely: Unit-Tests sollten vor der Entwicklung des eigentlichen Codes geschrieben werden.\nUnit-Tests erfüllen weitere Eigenschaften, daher sind weitere Lösungen denkbar.\nba)\nTestfall\nErgebnis des Tests\n1\nOK\n2\nFehler\n3\nFehler\n4\nOK\n5\nOK\nbb)\nint berechne Differenz (int zaehlerstandAlt, int zaehlerstandNeu) {\nint differenz = -1;\nif (zaehlerstandAlt >= 0 && zaehlerstandNeu >= 0} {\nif (zaehlerstandAlt <= zaeh [erstand Neu) {\ndifferenz = zaehlerstandNeu - zaehelerstandAlt;\n}\n}\nreturn differenz;\n}\nWeitere Lösungen sind möglich.\nbc)\nNr.\nzaehlerstandAlt\nzaehlerstandNeu\ndifferenz\n1\n-100\n80\n-1\n2\n-70\n0\n-1\n3\n-22\n-5\n-1\nSiehe Zeile 3 des Codes. Weitere Beispiele sind möglich.\n3.\nAufgabe Lösung\nWeitere Lösungen sind möglich.\n4.\nAufgabe Lösung\naa)\nWortwörtlich übersetzt, handelt es sich hierbei um eine gespeicherte Prozedur. Hierdurch können komplexe Abfolgen von SQL-\nAnweisungen unter einem Namen im Datenbank-Management-System (DBMS) abgespeichert werden. Diese Prozeduren können\nanschließend über den jeweiligen Namen aufgerufen und jederzeit ausgeführt werden.\nEine gespeicherte Prozedur kann von verschiedenen Datenbank-Clients genutzt werden. Änderungen an der Prozedur erfolgen zentral.\nab)\nBei einem Trigger handelt es sich um eine spezielle Art einer Stored Procedure. Die Prozedur wird beim Trigger automatisch ausgeführt,\nsobald ein Ereignis auf dem Datenbankserver auftritt.\nac)\nBei einem Datenbankindex handelt es sich um eine Datenstruktur mit Hilfe derer die Abfragegeschwindigkeit gesteigert werden kann.\nDaher wird die Indizierung genutzt, um insbesondere die Suche nach Datensätzen zu er­leichtern und zu beschleunigen. Vor allem bei\ngroßen Datenmengen wird hierdurch ein enormer Geschwindig­keitsvorteil ermöglicht.\nba)\nCREATE INDEX ldx_Datum ON Zaehlerstand (ZSt-Datum);\nbb)\nDELETE FROM Haushalte\nWHERE ( SELECT Count(Z_ID) FROM Zaehler WHERE Z_HHID = HH_ID ) = 0;\nAuch möglich:\nDELETE FROM Haushalte\nWHERE HH_ID NOT IN ( SELECT Z_HHID FROM Zaehler);\nbc)\nSELECT HH.HH_Nachname AS Nachname, Count(Z.Z_ID) AS AnzZaehler\nFROM Haushalte AS HH LEFT JOIN Zaehler AS Z ON HH.HH_ID = Z.Z_HHID\nGROUP BY HH.HH_Nachname\nORDER BY Count(Z.Z_ID) DESC;\nbd)\nSELECT HH.HH_Nachname AS Nachname, Z.Z_Nummer AS Zaehlernummer,\n(( SELECT ZSt.ZSt_Stand FROM ZaehlerStand AS ZSt WHERE Z.Z_ID = ZSt.ZSt_ZID AND YEAR(ZSt.ZSt_Datum) = 2022)\n(( SELECT ZSt.ZSt_Stand FROM ZaehlerStand AS ZSt WHERE Z.Z_ID = ZSt.ZSt_ZID AND YEAR(ZSt.ZSt_Datum) = 2021)) AS Verbrauch\nFROM Haushalte AS HH INNER JOIN Zaehler AS Z ON HH.HH_ID = Z.Z_HHID\nORDER BY HH_Nachname;\nEbenfalls denkbar:\nSELECT HH_Nachname AS Nachname, Z_Nummer AS Zaehlernummer, (Stand2022- Stand2021) AS Verbrauch\nFROM Haushalte INNER JOIN Zaehler ON HH_ID = Z_HHID\nINNER JOIN\n(\nSELECT ZSt_ZID, ZSt_Stand AS Stand2022\nFROM ZaehlerStand\nWHERE YEAR(ZSt_Datum) = 2022\n) AS qry22 ON Z_ID =qry22.ZSt_ZID\nINNER JOIN\n(\nSELECT ZSt_ZID, ZSt_Stand AS Stand2021\nFROM ZaehlerStand\nWHERE YEAR(ZSt_Datum) = 2021\n) AS qry21 ON Z_ID =qry21.ZSt_ZID\nORDER BY HH_Nachname;"}]},{"id":"winter_2022_23_teil2","season":"Winter","year":"2022/23","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Winter 2022/23 – Teil 2","tasks":[{"num":1,"points":25,"content":"Im Rahmen der Erstellung von Lernsoftware soll zunächst ein Sortieralgorithmus für ein Array von Raum-Objekten erstellt werden. Die Sortierung soll\naufsteigend nach der Belegungszahl eines Raumes erfolgen.\nRaum\n…\n+ getBelegung(): Integer\n…\nDer Sortieralgorithmus kann beispielsweise nach folgendem Verfahren arbeiten:\n-\nVergleich der ersten beiden Elemente, gegebenenfalls tauschen\n-\nVergleich des 2. und 3. Elementes, gegebenenfalls tauschen\n-\nFortführen des n. und n+ 1. Elementes bis zum Ende des Arrays\n-\nWiederholen, bis das Array sortiert ist\na)\nErstellen Sie einen Algorithmus, der ein Array von Raum-Objekten nach dem genannten oder einem alternativen Verfahren sortiert. Geben\nSie den Algorithmus in Pseudocode, Struktogramm oder als PAP an.\n(10 Punkte)\nvoid sort (raeume: Array von Raum)\nb)\nZur Flexibilisierung des Sortieralgorithmus wird eine Funktion benötigt, die ...\n-\nden Wert O zurückgibt, wenn die zwei der Funktion übergebenen Objekte gleich (,,groß\") sind,\n-\neinen positiven Wert zurückgibt, wenn der erste Parameter größer als der zweite ist und\n-\neinen negativen Wert im verbleibenden Fall.\nErstellen Sie eine Funktion vergleicheMitarbeiter(Mitarbeiter m1, Mitarbeiter m2), die zwei Mitarbeiter-Objekte als Parameter bekommt und\neinen entsprechenden Rückgabewert liefert. Der Vergleich der Mitarbeiter soll über das Gehalt vorgenommen werden.\nGeben Sie den Algorithmus in Pseudocode, Struktogramm oder als PAP an.\n(5 Punkte)\nMitarbeiter\n…\n+ getGehalt(): Double\n…\nvergleicheMitarbeiter(Mitarbeiter m1, Mitarbeiter m2): Integer\nc)\nDa nicht nur Raum-Objekte sortiert werden sollen, wird zur Erstellung eines flexibleren Algorithmus die Verwendung von generischen\nKlassen vorgeschlagen.\nErläutern Sie den Begriff generische Klasse.\n(3 Punkte)\nFortsetzung 1. Aufgabe\nd)\nZur Erstellung eines verbesserten Sortieralgorithmus soll die vorhandene generische Klasse Function<T> verwendet werden. Ein Function-\nObjekt kann eine Funktion speichern, die zwei Parameter vom Typ T erwartet und einen lntegerwert zurückgibt.\nVerwendung eines Function<T>-Objektes (Beispiel):\nSpeichern einer Funktion in einem Function-Objekt:\nFunction<Mitarbeiter> f = vergleicheMitarbeiter;\nAufruf der gespeicherten Funktion:\nf(mitarbeiter1, mitarbeiter2)\nZusätzlich soll für den neuen Sortieralgorithmus die vorhandene generische Klasse List<T> verwendet werden, die Objekte von Typ T\nspeichert.\nList<T>\n…\n+ get(index: Integer):T\n+ set(index: Integer, element: T):void\n+ size():Integer\n…\nAktualisieren Sie Ihren Sortieralgorithmus so, dass dieser als Parameter ein List<T>-Objekt und ein Function<T>-Objekt erhält. Für den\nVergleich im Sortieralgorithmus soll die im Function<T>-Objekt gespeicherte Funktion benutzt werden.\n(7 Punkte)\nsort(List<T> liste, Function<T> f): void"},{"num":2,"points":25,"content":"Für einen Kurs sollen Online-Lehrmittel erstellt werden. Sie erhalten die Aufgabe, einen vorgegebenen rekursiven Algorithmus zur Umrechnung einer\nDezimalzahl in eine Binärzahl mit einem Schreibtischtest auf Korrektheit zu prüfen und gegebenenfalls zu korrigieren.\na)\nFolgender Algorithmus in Pseudocode ist vorgegeben:\nvoid Umrechnung(dezimalzahl: int)\nBEGINN\nrest: int;\nrest = dezimalzahl modulo 2;\nAUSGABE(rest);\ndezimalzahl = dezimalzahl div 2; //div ist Division WENN dezimalzahl > 0 DANN\nUmrechnung(dezimalzahl);\nENDE\nENDE\naa) Führen Sie den Schreibtischtest aus und tragen Sie das Ergebnis in die rechte Spalte „ Ergebnis Schreibtischtest\" ein.\n4Punkte)\nTestfall\nDezimalzahl\nErwartetes Ergebnis\nErgebnis Schreibtiscshtest\n1\n7\n111\n2\n11\n1011\nab) Beschreiben Sie den Fehler und eine Korrekturmöglichkeit.\n(4 Punkte)\nac) Der Algorithmus soll in einem White-Box-Test geprüft werden.\nErklären Sie den Begriff Anweisungsüberdeckung und bestimmen Sie die mindestens benötigte Anzahl an Testfällen, um bei dem\ngegebenen Algorithmus Anweisungsüberdeckung zu erreichen.\n(3 Punkte)\nFortsetzung 2. Aufgabe\nb)\nBeschreiben Sie je einen Vor- und Nachteil der rekursiven Lösung im Vergleich zu einer iterativen Lösung.\n(4 Punkte)\nVorteil:\nNachteil:\nc)\nDer rekursive Algorithmus soll durch einen iterativen Algorithmus ersetzt werden. Eine Klasse List kann verwendet werden.\nFolgende Methoden der Klasse List stehen zur Verfügung:\ninsert(Wert:int) :void\nFügt den Wert „ Wert\" am Ende der Liste ein\nsize (): int\nliefert die Anzahl der Listenelemente\nelement(Pos:int)􀀎int\nliefert das Listenelement an Position Pos, Position O ist das Listenende\nList()\nKonstruktor erzeugt eine leere Liste\nErstellen Sie einen iterativen Algorithmus, der die Umrechnung korrekt ausführt.\n(10 Punkte)\nvoid Umrechnung(dezimalzahl: int)\nAnlage zu Aufgabe 3\nZusätzliche Anforderungen:\n-\n- Die Buchung soll in Verbindung zum betreuenden Mitarbeiter stehen.\n-\n- Die Standorte der Räume sollen auch erfasst werden."},{"num":3,"points":25,"content":"Wichtige Daten der Firma sollen in einer relationalen Datenbank gespeichert werden. Dazu liegt ein erstes ER-Modell vor, in dem schon die\nEntitätstypen Mitarbeiter und Serviceleistungen erfasst wurden. Dieses Modell soll nun um die Raumbuchungen von Kunden erweitert werden. Als\nGrundlage dafür steht Ihnen die nachfolgende Buchungsbestätigung und die danach aufgeführten Anforderungen zur Verfügung.\na)\nErweitern Sie das nachstehende ER-Modell zunächst nur um die notwendigen Entitätstypen und tragen Sie die Beziehung zwischen diesen\nmit den entsprechenden Kardinalitäten ein. (Hinweis: Attribute müssen nicht eingetragen werden.)\n(12 Punkte)\nb)\nAus dem ER-Modell soll im Anschluss ein relationales Datenmodell erstellt werden.\nÜberführen Sie dazu nur die (in Aufgabe 3a)) gegebenen Entitätstypen Mitarbeiter und Serviceleistung, deren Bezie­hung und alle Attribute\nin ein relationales Datenmodell, welches der 3. Normalform genügt.\nKennzeichnen Sie alle Primärschlüssel mit PK und alle Fremdschlüssel mit FK. Tragen Sie alle notwendigen Beziehungen mit den\nentsprechenden Kardinalitäten ein.\n10 Punkte)\nHinweis: Die Daten der Anschrift müssen nicht in einer eigenen Tabelle ausgelagert werden.\nFortsetzung 3. Aufgabe\nc)\nBei der Eingabe des relationalen Datenmodells müssen allen Attributen Datentypen zugeordnet werden.\nLegen Sie für nachfolgende Attribute sinnvolle Datentypen fest.\n(3 Punkte)\nAttribut\nDatentyp\nDauer\nPLZ\nName"},{"num":4,"points":25,"content":"Ein Auszug eines Datenbanksystems zu Mitarbeiterdaten liegt Ihnen wie folgt vor.\nMitarbeiter\nMa_ID\nNachname\nVorname\nStrasse\nPLZ\nOrt\nGebDat\nArbeitszeitTag\nAbt_ID\n1\nMeier\nWilhelm\nMusterstr. 22\n50733\nKöln\n23.11.19997\n8\n3\n2\nFranz\nAnja\nHauptstr. 333\n50737\nKöln\n02.02.1964\n4\n3\n3\nSchmitt\nAndrea\nAachenerstr. 5\n50968\nKöln\n02.08.1996\n8\n2\n4\nKreuzer\nPeter\nHauptstr. 155\n50734\nKöln\n05.09.1977\n8\n1\n5\nLang\nIna\nKölner Str. 221\n52063\nAachen\n11.11.2001\n8\n3\n6\nKurz\nKatrin\nKlichstr. 3\n50969\nKöln\n03.01.1979\n8\n1\n7\nPfennig\nPetra\nVon Bern Str. 5\n50999\nKöln\n08.10.1956\n6\n1\n8\nKrenz\nKarin\nPeterstr.\n50997\nKöln\n19.12.1988\n8\n2\n…\nAbteilung\nAbt_ID\nAbteilung\n1\nVerwaltung\n2\nProduktion\n3\nEntwicklung\n…\nFehlzeit\nFz_ID\nMa_ID\nFzA_ID\nVonDat\nBisDat\nFehltageSum\n1\n2\n1\n10.05.2022\n20.05.2022\n9\n2\n5\n2\n16.05.2022\n29.05.2022\n10\n3\n3\n1\n18.05.2022\n22.05.2022\n3\n4\n1\n1\n19.05.2022\n22.05.2022\n2\n5\n1\n2\n23.05.2022\n29.05.2022\n5\n6\n7\n2\n30.05.2022\n19.06.2022\n15\n7\n6\n3\n25.05.2022\n26.05.2022\n2\n8\n6\n3\n06.06.2022\n08.06.2022\n3\n9\n1\n1\n27.06.2022\n29.06.2022\n3\n…\nJahresübergreifende Fehlzeiten werden getrennt nach Jahr eingetragen.\nBei FehltageSum werden Wochenenden und freie Tage nicht als Fehltage gezählt.\nFehlzeitArt\nFzA_ID\nFehlzeitart\n1\nAU\n2\nUrlaub\n3\nDienstreise\n…\nFortsetzung 4. Aufgabe\na)\nErstellen Sie eine SQL-Abfrage, mit der alle Mitarbeiter mit Abteilungen, den summierten Urlaubstagen sowie der Anzahl der\nUrlaubseinträge im Jahr 2022 ausgegeben werden.\n10 Punkte)\nDie Ergebnistabelle soll wie folgt aussehen:\nID\nNachname\nVorname\nAbteilung\nUrlaubstage\nUrlaubseintraege\n1\nMeier\nWilhelm\nEntwicklung\n5\n1\n2\nFranz\nAnja\nEntwicklung\n0\n3\nSchmitt\nAndrea\nProduktion\n0\n4\nKreuzer\nPeter\nVerwaltung\n0\n5\nLang\nIna\nEntwicklung\n10\n1\n6\nKurz\nKatrin\nVerwaltung\n0\n7\nPfennig\nPetra\nVerwaltung\n15\n1\n8\nKrenz\nKarin\nProduktion\n0\n…\nb)\nErstellen Sie die notwendigen SQL-Anweisungen, mit der Sie mit den Daten aus der Tabelle Fehlzeit vom Mitarbeiter Wilhelm Meier\n(Ma_lD: 1) in die Tabelle Fehlzeit_Archiv verschieben (kopieren und löschen) können.\n(10 Punkte)\nHinweis: Die Tabelle Fehlzeit_Archiv existiert und hat die gleiche Struktur wie die Tabelle Fehlzeit.\nc)\nErstellen Sie eine SQL-Abfrage, mit der alle Mitarbeiter ausgegeben werden, welche an der vierten Stelle der Postleitzahl (als Zeichenkette\nangelegt) die Ziffer 3 enthalten.\n(5 Punkte)\nDie Ergebnistabelle lautet wie folgt:\nMa_ID\nNachname\nPLZ\nOrt\n1\nMeier\n50734\nKöln\n2\nFranz\n50737\nKöln\n4\nKreuzer\n50733\nKöln\nLösungshinweise Winter 2022/23 Teil 2 - Entwicklung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\na)\nb)\nHinweis:\nEine Lösung mit Rückgabe m1.getGehalt() – m2.getGehalt() führt zu einem Typkonflikt zwischen Integer und Double. Eine Typkonvertierung\nvon Gehalt zu Integer führt zu nicht richtigen Ergebnissen!\nc)\nEine generische Klasse ist eine typparametrisierte Klasse, das heißt Methoden und Variablen werden für einen vorgegebenen, aber\nbeliebigen Typ definiert. Für den vorgegebenen Typ können Einschränkungen formuliert werden.\nd)\n2.\nAufgabe Lösung\naa)\nTestfall\nDezimalzahl\nErwartetes Ergebnis\nErgebnis Schreibtiscshtest\n1\n7\n111\n111\n2\n11\n1011\n1101\nab)\nDie Ausgabe „Ausgabe(rest);“ erfolgt vor dem rekursiven Aufruf „Umrechnung(dezimalzahl);“, beim Abstieg in die Rekursion. Daher ist das\nErgebnis in der falschen Reihenfolge.\nKorrektur: Ausgabe nach dem rekursiven Funktionsaufruf.\nKorrekte Alternativen sind ebenfalls als richtig zu werten.\nac)\nUm Anweisungsüberdeckung zu erreichen, muss durch die Auswahl der Testfälle sichergestellt werden, dass jede Anweisung mindestens\n1-mal ausgeführt wird.\nBeim gegebenen Programm genügt ein Testfall.\nb)\nz. B.:\nVorteil: Rekursive Lösungen sind zum passenden Problem einfacher oder eleganter zu schreiben.\nNachteil: Rekursive Lösungen benötigen mehr Speicher zur Laufzeit.\nKorrekte Alternativen sind ebenfalls als richtig zu werten.\nc)\n3.\nAufgabe Lösung\na)\n1 Punkt für jeden richtigen Entitätstyp = 6 Punkte, 1 Punkt für jede richtige Beziehung = 6 Punkte\nKorrekte Alternativen sind ebenfalls als richtig zu werten.\nb)\nTabelle Mitarbeiter/Tätigkeit je 3 Punkte, Tabelle Serviceleistung 2 Punkte, je Beziehung 1 Punkt\nKorrekte Alternativen sind ebenfalls als richtig zu werten.\nc)\nAttribut\nDatentyp\nDauer\nInteger\nPLZ\nVarChar (String ,Text)\nName\nVarChar (String ,Text)\nKorrekte Alternativen sind ebenfalls als richtig zu werten.\n4.\nAufgabe Lösung\na)\nb)\nc)"}]},{"id":"sommer_2023_teil2","season":"Sommer","year":"2023","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Sommer 2023 – Teil 2","tasks":[{"num":1,"points":25,"content":"Sie werden von Ihrem Ausbilder beauftragt, den Prozess zur Anlage neuer Pflanzungen mittels eines UML-Aktivitätsdiagramms zu dokumentieren.\nUm den Prozess zu verstehen, sprechen Sie mit mehreren Mitarbeitern.\nSie beginnen mit einem Mitarbeiter der Gartenplanung.\nDieser teilt Ihnen mit, dass er den Gärtnern den Auftrag einer neuen Pflanzung erteilt.\nWenn die Gärtner fertig gepflanzt haben, fertigt er Bilder des neuen Bereichs an. Wenn die Bilder gemacht sind und der Einkauf die Rechnung bezahlt\nhat, ist der Vorgang abgeschlossen.\nInformationen eines Gärtners:\nWenn der Gärtner einen neuen Pflanzauftrag vom Gartenplaner erhält, stellt er zuerst die Anforderungen zusammen und sagt dem Einkauf welche\nPflanzen zu bestellen sind.\nWenn Pflanzen ankommen, bekommt er diese vom Einkauf und bringt die Pflanzen in die Quarantänestation. Der Gärtner prüft täglich die Pflanzen\nund kontrolliert das Quarantäneende.\nIst eine Pflanze in Quarantäne erkrankt, so muss diese behandelt und die Quarantäne für alle Pflanzen verlängert werden.\nSind alle Pflanzen gesund und die Quarantäne abgelaufen pflanzt der Gärtner die Pflanzen.\nNach Abschluss der Pflanzarbeiten macht die Gartenplanung noch Bilder.\nDer Einkauf gibt Ihnen folgende Hinweise:\nDer Gärtner teilt uns mit was er braucht, dann bestellen wir diese Pflanzen bei unserem Lieferanten. Bei Anlieferung übergeben wir die Pflanzen an\nden Gärtner und bezahlen die Rechnung.\nWeiterhin beschreibt der Einkauf den Vorgang beim Lieferanten so, dass der Lieferant den Auftrag annimmt, danach die Lieferung zusammenstellt\nund dann die Pflanzen ausliefert.\nVervollständigen Sie aufgrund der erhaltenen Informationen das auf der nächsten Seite abgebildete Aktivitätsdiagramm.\nGartenplanung\nGärtner\nEinkauf\nLieferant"},{"num":2,"points":25,"content":"Die Verwaltung des Parks möchte eine Auswertung über die Besucherzahlen für alle Tage eines vorgegebenen Monats erhalten. Für die\nBesuchertickets werden daher an den Ein - und Ausgängen folgende Informationen festgehalten:\n-\nDas Ticket wird beim Einlass gescannt und damit das Datum, die Uhrzeit und die Anzahl der Personen (Gruppentickets) gespeichert.\n-\nBeim Hinausgehen wird jede Person mit Datum und Uhrzeit einzeln erfasst.\nDer Park hat aktuell die Öffnungszeiten von 9:00 Uhr bis 19:00 Uhr.\nZur Auswertung soll für jeden Tag eines Monats festgehalten werden, wie viele Personen sich von 9:00 Uhr bis 9:59 Uhr, von 10:00 Uhr bis 10:59 Uhr,\n... und von 18:00 Uhr bis 18:59 Uhr aufgehalten haben.\nDie folgende Klasse ist bereits vorhanden:\nComeLeave\n- date: Date\n- comeInOut: Integer\n- noPeople: Integer\n…\nFür jedes Attribut sind öffentliche Zugriffsmethoden (set/get) vorhanden.\nFolgende Methoden können verwendet werden:\ngetDay() der Klasse Date\nErmittelt zum Datum den Tag ( 1 - 31)\ngetHour() der Klasse Date\nErmittelt zum Datum die Stunde (0 - 23)\ngetDaysOfMonth() der Klasse Date\nErmittelt zum Datum die Anzahl der Tage im Monat\nIn der Tabelle entry vom Typ Comeleave sind die Kommen - und Gehenzeiten der Besucher für den auszuwertenden Monat erfasst (eine Zeile\nentspricht den Attributen eines Objektes vom Typ Comeleave):\nDate\nTime\ncomeInOut (0 = In / 1 = Out)\nnoPeople\n…\n22.5.2023\n9:00\n0\n1\n22.5.2023\n9:00\n0\n2\n22.5.2023\n9:01\n0\n30\n…\n22.5.2023\n12:00\n1\n1\n22.5.2023\n12:01\n0\n2\n22.5.2023\n12:02\n1\n1\n…\nErstellen Sie auf der folgenden Seite eine Funktion countVisitors(entry: ComeLeave) : Integer[][]. die folgende Anforderung erfüllt:\n-\nFür jede Stunde eines Tages (Öffnungszeiten!) und für jeden Tag des auszuwertenden Monats soll die Anzahl der anwesenden Personen in\neinem zweidimensionalen Array vom Typ Integer gespeichert werden.\nFür jeden Tag des Monats soll eine Zeile und für jede Stunde innerhalb der Öffnungszeit eine Spalte verwendet werden.\nDieses Array ist der Rückgabewert der Funktion countVisitors().\nDabei wird eine Person ab einem Stundenabschnitt gezählt, wenn sie in diesem Abschnitt den Park betreten hat. Wenn eine Person den\nPark verlässt, wird die Anzahl erst für die nachfolgenden Abschnitte entsprechend korrigiert.\nBeispielarray für ein Ergebnis:\nTag/Std\n9:00-\n9:59\n10:00-\n10:59\n11:00-\n11:59\n12:00-\n12:59\n13:00-\n13:59\n14:00-\n14:59\n15:00-\n15:59\n16:00-\n16:59\n17:00-\n17:59\n18:00-\n18:59\n1\n23\n40\n56\n120\n145\n160\n140\n95\n86\n45\n2\n27\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n31\n…\n…\n…\n…\n…\n…\n…\n…\n…\ncountVisitors(entry: Comeleave): lnteger[)I]"},{"num":3,"points":25,"content":"Die Verwaltung des Parks hat eine Jahresstatistik für die Nutzung der Monatstickets in Auftrag gegeben. Die implementierte Methode soll einem Test\nunterzogen werden. Die Daten liegen in einer Liste, aufsteigend sortiert nach Monat, vor und haben die folgende Struktur:\nstruct TicketData\n{\nint Id;\n//Ticket-Id\nstring Monat;\n//Monat\nstring Jahr;\n//Jahr\nint NutzungsZaehler;\n//Anzahl der Nutzungen (tagesweise)\n}\nFür den Test sollen die folgenden Testdaten verwendet werden:\nId\nMonat\nJahr\nNutzungszaehler\n0\nJanuar\n2023\n31\n1\nJanuar\n2023\n31\n2\nFebruar\n2023\n28\nAus diesen Daten soll die folgende Ausgabe generiert werden:\nNutzungsstatistik Monatstickets\nAuswertung für Monat   Januar\nMinimale Nutzung:      31\nMaximale Nutzung:      31\nDurchschnitt:          31\nGesamtanzahl Tickets:  2\nAuswertung für Monat     Februar\nMinimale Nutzung:      28\nMaximale Nutzung:      28\nDurchschnitt:          28\nGesamtanzahl Tickets:  1\nAuswertung für Jahr 2023\nMinimale Nutzung:      28\nMaximale Nutzung:      31\nDurchschnitt:          30\nGesamtanzahl Tickets:  3\na)\nÜberprüfen Sie den Code auf der folgenden Seite (Anlage zu Aufgabe 3) mit Hilfe der oben genannten Testdaten. Verwenden Sie dazu die\nDatenverlaufstabelle.\nDatenverlaufstabelle:\nTyp\nVariable/Ausdruck\nWerteverlauf\nstring\nmonat\nint\nmonatMin\nint\nmonatMax\nint\nmonatTicketZaehler\nint\nmonatNutzungsZaehler\nint\njahrMin\nint\njahrMax\nint\njahrTicketZaehler\nint\njahrNutzungsZaehler\nTicketData\ntd\naa) Nennen Sie kurz zwei gefundene Fehler.\n(2 Punkte)\nAnlage zu Aufgabe 3\n01\n02\n03\n04\n05\n06\n07\n08\n09\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nTicketStatistik(list<TicketData> TicketDatalist) void\nWriteln(\"Nutzungssstatistik Monatstickets\");\nWriteLn();\nTicketData td0 = TicketDatalist[0];\nstring monat td0.Monat;\nint monatMin = GetMonatstage(monat);\nint monatMax = 0;\nint monatTicketZaehler = 0;\nint monatNutzungsZaehler = 0;\nint jahrMin = 31;\nint jahrMax = 0;\nint jahrTicketZaehler = 0;\nint jahrNutzungsZaehler = 0;\nforeach(TicketData td in TicketDatalist)\nif ( monat != td.Monat )\n//Monatsauswertung:\nWriteln(\"Auswertung für Monat\" + monat);\nWriteLn(\" Minimale Nutzung:\" + monatMin);\nWriteLn(\" Maximale Nutzung:\" + monatMax);\nWriteln(\" Durchschnitt:\" + monatNutzungsZaehler/monatTicketZaehler);\nWriteLn(\" Gesamtanzahl Tickets:\" + monatTicketZaehler);\nWriteLn();\n//Monatsdaten für Jahresauswertung übernehmen:\njahrTicketZaehler = jahrTicketZaehler + monatTicketZaehler;\njahrNutzungsZaehler = jahrNutzungsZaehler + monatNutzungsZaehler;\nif ( jahrMax < monatMax )\njahrMax = monatMax;\nend if\nif ( jahrMin > monatMin )\njahrMin = monatMin;\nend if\n//Reset Monat:\nmonatTicketZaehler 0;\nmonatNutzungsZaehler = 0;\nmonatMax = 0;\nmonat = td.Monat;\nmonatMin = GetMonatstage(monat);\nend if\n//Ticketauswertung:\nmonatTicketZaehler += 1;\nmonatNutzungsZaehler += td.NutzungsZaehler;\nif ( monatMax < td.NutzungsZaehler )\nmonatMax = td.NutzungsZaehler;\nend if\nif ( monatMin > td.NutzungsZaehler\nmonatMin = td.NutzungsZaehler;\nend if\nend foreach\n//Jahresauswertung:\nWriteLn(\"Auswertung für Jahr\" + td0.Jahr);\nWriteln(\" Minimale Nutzung:\" + jahrMin);\nWriteLn(\" Maximale Nutzung:\" + jahrMax);\nWriteLn(\" Durchschnitt:\" + jahrNutzungsZaehler / monatTicketZaehler);\nWriteLn(\" Gesamtanzahl Tickets\" + jahrTicketZaehler);\nWriteLn();\nend Ticketstatistik\nFortsetzung 3. Aufgabe\nab) Machen Sie Vorschläge für die Änderung bzw. Erweiterung des Codes, so dass die erwartete Ausgabe erzeugt wird.\n(13 Punkte)\nb)\nDer Test soll alle Anweisungen mindestens einmal durchlaufen (Anweisungsüberdeckung, coverage test).\nba) Erläutern Sie die Anweisungsüberdeckung.\n(2 Punkte)\nbb) Mit den vorgegebenen Testdaten werden nicht alle Anweisungen des Codes durchlaufen.\nNennen Sie die Anweisungen, die nicht durchlaufen werden.\n(4 Punkte)\nbc) Passen Sie die Testdaten so an, dass alle Anweisungen durchlaufen werden und begründen Sie ihre Veränderungen.\n(4 Punkte)"},{"num":4,"points":25,"content":"Es liegt nachfolgender Datenbankauszug zur Verwaltung der Pflegearbeiten im botanischen Garten vor. Für die Verwaltung und Auswertung der Daten\nsoll die Datenbankabfragesprache SQL zum Einsatz kommen.\nObjekt\nMitarbeiter\nTaetigkeit\nPflegearbeit\nPID\nOID\nTID\nMID_Sol\nMID_Ist\nDatum_Soll\nDatum_Abschluss\n1\n1\n2\n31\n31\n20.04.2023\n20.04.2023\n2\n1\n2\n2\n2\n11.05.2023\nNULL\n3\n2\n1\n1\n2\n20.03.2023\n21.03.2023\n4\n2\n1\n1\nNULL\n01.08.2023\nNULL\n5\n2\n3\n31\nNULL\n28.07.2023\nNULL\na)\nErstellen Sie eine SQL-Abfrage, mit der die Anzahl der Pflegearbeiten ermittelt wird, welche im Jahr 2023 geplant aber noch nicht\nabgeschlossen sind.\n(5 Punkte)\nMID\nName\nVorname\n1\nRose\nInes\n2\nBaum\nJürgen\n31\nHolz\nWalter\nTID\nBezeichnung\n1\nRosenschnitt\n2\nRasen mähen\n3\nUnkraut jäten\nOID\nBezeichnung\n1\nRasenfläche Süd\n2\nRosenoarten\n3\nTropenhaus\nFortsetzung 4. Aufgabe\nb)\nErstellen Sie eine SQL-Abfrage, mit der Sie ermitteln, an welchen Wochentagen in der Zeit vom 19.06.2023 bis einschließlich 30.06.2023\nwelche Pflegearbeiten in der „Außenanlage Nord\" stattfinden sollen. Das Ergebnis soll nach dem Datum aufsteigend sortiert angezeigt\nwerden.\n(8 Punkte)\nBeispiel-Ergebnistabelle:\nDatum\nWochentag\nTätigkeit\n19.06.2023\nMontag\nHeckenschnitt\n19.06.2023\nMontag\nRasen mähen\n22.06.2023\nDonnerstag\nUnkraut jäten\n26.06.2023\nMontag\nRosenschnitt\n30.06.2023\nFreitag\nRosenschnitt\nc)\nErstellen Sie eine SQL-Abfrage, mit der Sie die durchschnittliche Anzahl der Tätigkeiten pro Monat im Jahr 2021 von jedem Mitarbeiter\nauflisten.\n8 Punkte)\nBeispiel-Ergebnistabelle:\nMID\nName\nVorname\nDurchschnitt\n1\nRose\nInes\n25,3\n2\nBaum\nJürgen\n17,8\n19\nKnoll\nJana\n0\n31\nHolz\nWalter\n30,2\nd)\nGeben Sie alle SQL-Anweisungen an, welche notwendig sind, um einen neuen Nutzer „Maier\" mit dem Passwort „5jk2T?\" zu erstellen und\ndiesem die Leserechte an der Tabelle Objekt zuzuweisen.\n(4 Punkte)\nLösungshinweise Sommer 2023 Teil 2 - Entwicklung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\nWeiterführende Informationen:\nNachfolgende einige kurze Regeln für die Erstellung eines UML-Aktivitätsdiagramms:\n1.\nVerwende Aktivitäten, um Aktionen oder Operationen darzustellen, die im Prozess ausgeführt werden.\n2.\nVerbinde Aktivitäten mit Pfeilen, um den Fluss der Ausführung anzugeben.\n3.\nVerwende Entscheidungsdiamanten, um Verzweigungen oder Entscheidungspunkte im Prozess darzustellen.\n4.\nNutze Synchronisationsbalken, um parallele Aktivitäten darzustellen, die gleichzeitig ausgeführt werden.\n5.\nVerwende Swimlanes, um unterschiedliche Rollen, Abteilungen oder Akteure im Prozess zu repräsentieren.\n6.\nVerwende Start- und Endsymbole, um den Beginn und das Ende des Prozesses zu kennzeichnen.\n7.\nHalte Aktivitäten klar, einfach und gut benannt, um die Lesbarkeit zu verbessern. Aktivitäten sollten darüber hin- aus immer mit\ngeeigneten Adjektiven beschrieben sein.\n8.\nDokumentiere Bedingungen, Schleifen oder Wiederholungen, um komplexe Abläufe im Prozess zu verdeutlichen.\n9.\nOptional: Verwende Kommentare oder Notizen, um zusätzliche Informationen oder Erläuterungen hinzuzufügen.\n10. Halte das Diagramm übersichtlich und gut strukturiert, um eine klare Darstellung des Prozesses zu gewährleisten.\nDiese Regeln dienen als allgemeine Richtlinien, um ein UML-Aktivitätsdiagramm verständlich und aussagekräftig zu gestalten. Es ist\nwichtig, den Kontext und die spezifischen Anforderungen des Projekts zu berücksichtigen, um anschlie­ßend das Diagramm entsprechend\nanzupassen.\n2.\nAufgabe Lösung\nWichtige Anmerkung zu dieser Aufgabe:\nDie Angaben der Aufgabenstellung enthalten Fehler, daher kann diese Aufgabe nicht zweifelsfrei bearbeitet werden. Aufgrund dieser und\nweiterer Unstimmigkeiten in der Angabe, wurde seitens der ZPA-Nord-West eine Empfehlung aus­gesprochen, diese Aufgabe generell mit 25\nPunkte zu bewerten.\nDennoch findest du nachfolgend einen Lösungsversuch:\ncountVisitors(entry: ComeLeave) : Integer[][]\ncount_entry = entry.length;\ncount_visitor = entry[O] .getDate() .getDaysOfMonth() * 10;\nvisitors = new Integer [ count_ visi tor] [];\nfor (i = 0; i < count entry; i++)\n{\nday = entry[i] .getDate() .getDay();\nhour = entry[i] .getDate() .getHour();\nindex_row = day - l;\nindex column = hour - 9;\nif (entry[i] .getComeinOut() == 0)\n{\nfor (j = index column; j <= 9; j++)\n{\nvisitors[indJx_row] [j] = visitors[index row] [j]\n+ entry[i] .getNoPeople()\n}\n}\nelse\n{\nfor (j = index column + 1; j <= 9; j++)\n{\nvisitors[index row] [j] = visitors[index_row] [j] - 1;\n}\n}\n}\nreturn visitors;\n}\nend countVisitors\n3.\nAufgabe Lösung\na)\nVariable/Ausdruck\nIteration 1\nInteration 2\nmonat\nJanuar\nFebruar\nmonatMin\n31\n28\nmonatMax\n31\n31\nmonatTicketZaehler\n2\n1\nmonatNutzungsZaehler\n62\n28\njahrMin\n31\n28\njahrMax\n31\n31\njahrTicketZaehler\n2\n3\njahrNutzungsZaehler\n62\n90\nDie Datenverlaufstabelle wird nicht bewertet und kann daher unterschiedlich verwendet/ nicht verwendet werden.\naa)\nFehler 1: Der letzte Monat (Februar) wird nicht ausgewertet.\nFehler 2: Der Jahresdurchschnitt wird falsch berechnet.\nWeiterführende Informationen:\nIm Code wird überprüft, ob der Monat ungleich td.Monat ist (,,monat != td.Monat\"), bevor die Monatsauswertung durchführt wird. Da dies\nam Ende der Schleife geschieht, wird der Februar nicht ausgewertet, da es keinen weite­ren Monat gibt, der nach ihm kommt. Das führt\ndazu, dass die Auswertung für den Februar fehlt.\nIm Code wird zur Ermittlung des Durchschnittes eine Division aus „jahrNutzungsZaehler\" und „monatTicketZaehler\" verwendet.\n,,monatTicketZaehler\" enthält allerdings nur die Anzahl der Tickets im letzten Monat.\nab)\nKorrekturvorschlag zur Berücksichtigung des letzten Monats:\nZusätzlicher Code nach Zeile 48:\n…\n//Monatsauswertuni (Letzter Monat):\nWriteLn(\"Auswertung für Monat\" + monat);\nWriteLn(\" Minimale Nutzung:\" + monatMin);\nWriteLn(\" Maximale Nutzung:\" + monatMax);\nWriteLn(\" Durchschnitt:\" + mona:tNutzungsZaehler / monatTicketZaehLer) ;\nWriteLn(\" Gesamtanzahl Tickets:\" + monatTicketZaehler);\nWriteLn ();\n//Monatsdaten für Jahresauswertung übernehmen (Letzter Monat): jahrTicketZaehler = jahrTicketZaehler +\nmonatTicketZaehLer; jahrNutzungsZaehler = jahrNutzungsZaehler + monatNutzungsZaehLer;\nif ( jahrMax < monatMax\njahrMax = monatMax;\nend if\nif ( jahrMin > monatMin\njahrMin monatMin;\nend if\nAlternative Lösungen sind möglich.\nKorrekturvorschlag zur korrekten Berechnung des Durchschnittes:\nKorrektur von Zeile 53:\nWriteLn(\"Durchschnitt:\" + jahrNutzungsZaehler / jahrTicketZaehler);\nAlternative Lösungen sind möglich.\nba)\nUnter einer Anweisungsüberdeckung versteht man eine Metrik im Softwaretest, welche angibt, wie viele der Anweisungen im\nProgrammcode während der Testdurchführung ausgeführt wurden. Ziel ist es, dass jede Anweisung mindestens einmal durchlaufen wird.\nDie Anweisungsüberdeckung ist eine wichtige Kennzahl, um die Qualität und Effektivität von Tests zu bewerten und potenzielle Fehler im\nCode aufzudecken.\nbb)\nDie Anweisung in Zeile 46 „monatMin = td. NutzungsZaehler;\" wird nicht durchlaufen, da bei den gegebenen Testdaten monatMin\nnicht größer als td.NutzungsZaehler ist.\nEs ist davon auszugehen, dass eventuelle Schaltjahre nicht zu berücksichtigen sind.\nbc)\nDie Testdaten sind so anzupassen, dass als Nutzungszaehler für Februar ein Wert unter 28 gewählt wird (z. B.12).\n4.\nAufgabe Lösung\na)\nSELECT COUNT ( *) AS Anzahl\nFROM Pflegearbeit\nWHERE YEAR(Datum_Soll) = 2023 AND Datum Abschluss IS NULL; Die Benennung der Ausgabe als Anzahl (AS Anzahl) ist optional.\nb)\nSELECT P.Datum_Soll AS Datum,\nWEEKDAY(P.Datum_Soll) AS Wochentag,\nT.Bezeichnung AS Taetigkeit\nFROM Objekt AS 0\nINNER JOIN Pflegearbeit AS p ON O.OID = P.OID\nINNER JOIN Taetigkeit AS T ON T.TID = P.TID\nWHERE P.Datum Soll >= '2023-06-19' AND P.Datum Soll <= '2023-06-30' AND O.Bezeichnung = 'Außenanlage Nord'\nORDER BY P.Datum Soll ABC;\nc)\nSELECT M.MID, M.Name, M.Vorname, (COUNT(P.MID_Ist) / 12) AS Durchschnitt\nFROM Mitarbeiter AS M\nLEFT JOIN Pflegearbeit AS P ON M.MID P.MID Ist AND\nYEAR(P.Datum_Abschluss) = 2021\nGROUP BY M.MID, M.Name, M.Vorname;\nAlternative Lösung:\nSELECT M.MID, M.Name, M.Vorname, (COUNT(P.MID_Ist) / 12) AS Durchschnitt FROM Mitarbeiter AS M\nLEFT JOIN (\nSELECT MID Ist\nFROM Pflegearbeit\nWHERE YEAR(Datum_Abschluss) = 2021\n)\nAS P ON M.MID = P.MID Ist\nGROUP BY M.MID, M.Name, M.Vorname;\nd)\nCREATE USER 'Maier' IDENTIFIED BY 'Sjk2T?';\nGRANT SELECT ON Objekt TO 'Maier';"}]},{"id":"winter_2023_24_teil2","season":"Winter","year":"2023/24","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Winter 2023/24 – Teil 2","tasks":[{"num":1,"points":25,"content":"Um auf die Güte des Weins schließen zu können, soll eine App entwickelt werden, die anhand von Messungen an den Trauben vor der Weinlese über\ndie Güte Auskunft geben kann.\nNach dem Aufruf der App kann der zuvor gemessene Säuregehalt der Trauben eingegeben werden (Methode einlesenSaeuregehalt() der Klasse GUI).\nIst der Säuregehalt zu hoch, werden keine weiteren Messungen mehr vorgenommen.\nEs erfolgt die Ausgabe „Säuregehalt zu hoch\" (Methode ausgabe(\" ... \") der Klasse GUI).\nWenn der Säuregehalt nicht zu hoch ist, wird der Oechslegrad eingegeben (einlesenOechslegrad() der Klasse GUI).\nAnschließend erfolgt die Berechnung des Reifegrads durch die Methode berechneReifegrad(oechslegrad) der Klasse Ernterechner. Falls der Reifegrad\ngrößer oder gleich 100 ist, erfolgt die Ausgabe „hoher Reifegrad\".\nFalls der Reifegrad größer oder gleich 80 (und kleiner als 100) ist, erfolgt die Ausgabe „ mittlerer Reifegrad\".\nFalls der Reifegrad größer oder gleich 70 (und kleiner als 80) ist, erfolgt die Ausgabe „ niedriger Reifegrad\".\nErstellen Sie auf der Folgeseite für den beschriebenen Sachverhalt ein Sequenzdiagramm."},{"num":2,"points":25,"content":"Für den Flug der Drohnen soll die Reihenfolge bestimmt werden, in der vorgegebene Geopositionen angeflogen werden.\nAusgehend von der aktuellen Position soll immer die Position als nächstes angeflogen werden, die der aktuellen Position am nächsten liegt.\nDie anzufliegenden Positionen liegen in einem eindimensionalen Array geoPositions als Objekte der Klasse GeoPos vor.\nGeoPos\n- latitude: double\n- longitude: double\n- altitude: double\nZu jedem Attribut sind öffentliche Zugriffsmethoden (set/get) vorhanden.\nFür Entfernungsberechnungen zwischen Geopositionen kann die Methode getDistance der Klasse GeoCalculator verwendet werden:\nGeoCalculator\n+ getDistance(pos1: GeoPos, pos2: GeoPos): double {static}\nDer Algorithmus für den Drohnenflug soll sein Ergebnis in einem Array flightPositions speichern und zurückgeben. Die Arbeitsweise des Algorithmus\ncalculateFlight() wird wie folgt beschrieben:\n-\nDas Array geoPositions kann durch den Algorithmus verändert werden.\n-\nDie Geoposition mit dem Index O des Arrays geoPositions wird zur ersten aktuellen Position. Diese Position wird im Array flightPositions\ngespeichert (Startposition!) und kann dann aus dem Array der noch anzufliegenden Positionen (geoPositions) gelöscht werden. Hinweis:\nbereits implementiert, siehe Vorgabe.\n-\nSolange noch Geopositionen im Array geoPositions vorhanden sind:\nErmitteln der Position im Array geoPositions mit der kürzesten Entfernung zur aktuellen Position.\nDiese Position wird im Array flightPositions gespeichert und zur neuen aktuellen Position.\nDiese Position kann dann aus dem Array geoPositions gelöscht werden.\nHinweis: Der größte Doublewert kann mit Double.MAX_VALUE abgerufen werden. Vervollständigen Sie dahingehend den Pseudocode.\ncalculateFlight(geoPositions: GeoPos[] ) : GeoPos[]\nflight_positions = new GeoPos[geoPositions.length]    // Array der angeflogenen\n// Positionen\nflightPositions[0] = geoPositions[0]                  // Position 0 als Startposition\ncurrentPos = geoPositions[0]\ngeoPositions.remove(0)                         // aus dem Array der noch anzufliegenden Positionen entfernen"},{"num":3,"points":25,"content":"a)\nFür den Weinberg sollen die Messstellen sowie die Messgeräte und deren Messdaten in einer relationalen Datenbank verwaltet werden. Als\nGrundlage zur Entwicklung des relationalen Datenmodells liegen nachfolgende Angaben vor:\nDie Messstellen sind an verschiedenen Stellen auf dem Weinberg verteilt. Die Position einer Messstelle wird genau durch ihre\nGeokoordinaten (Längen- und Breitengrad sowie die Höhe) beschrieben. Jede Messstelle liefert Messwerte von verschiedenen Messgrößen\nwie z. B. Messgröße = Temperatur, Messwert= 22, Einheit= 0C. Für die einzelnen Messwerte sollen weiterhin auch noch der Zeitpunkt der\nMessung (Datum, Uhrzeit) und die Messstelle erfasst werden.\nAn jeder Messstelle können mehrere Messgeräte eingesetzt werden, welche die Messwerte erfassen und weiterleiten. Dabei ist nur\nrelevant, welches Messgerät aktuell an welcher Messstelle eingesetzt wird. Historische Daten spielen keine Rolle. Für jedes Messgerät\nsollen folgende Angaben erfasst werden: Bezeichnung, Herstellungsdatum, Hersteller, Anschaffungsdatum und das Datum der letzten\nÜberprüfung.\nErstellen Sie aus diesen Angaben für die Messwerterfassung ein relationales Datenmodell in der dritten Normalform. Geben Sie\nKardinalitäten an und kennzeichnen Sie die Primärschlüssel mit PK und die Fremdschlüssel mit FK.\n(18 Punkte)\nb) Weiterhin sollen Bilder der autonomen Drohnen für die weitere Verarbeitung und Auswertung z. B. durch eine KI unkomprimiert in einem\n„ Raw\" -Format gespeichert werden. Die Drohnen fliegen einmal pro Woche über den Weinberg und machen pro Flug jeweils 200 Bilder.\nDie Kamera liefert Bilder mit 20 Megapixeln. Die Farben pro Pixel werden im RGB-Format abgespeichert, wobei pro Farbkanal 8 Bit\nverwendet werden.\nBerechnen Sie den benötigten Speicherbedarf in GiB, welcher für die Bilder innerhalb eines Jahres (52 Wochen) anfällt. Runden Sie auf\nganze GiB. Der Rechenweg ist anzugeben.\n(7 Punkte)"},{"num":4,"points":25,"content":"Für die Kundenverwaltung und die Warenwirtschaft sind folgende Tabellen vorhanden.\nTabelle: Kunde\nKd_IdKey\nKd_Firma\nKd_Strasse\nKd_PLZ\nKd_Ort\nKd_Nummer\n1\nLikeLimo\nMusterstr. 12\n50778\nKöln\n012204\n2\nGasthaus Die Perle\nPerlenstr. 22\n50778\nKöln\n012201\n3\nTraberstübchen\nTraberweg 1\n50889\nKöln\n012205\n…\nTabelle: Artikel\nArt_IdKey\nArt_Nummer\nArt_Bezeichnung\nArt_Preis\nArt_VkEinheit\nArt_MwStSatz\nArt_Jahrgang\nArt_WAIdKey\n8\nGB-12555\nGrauburgunder\n15.20\nFlasche\n19.00\n2005\n1\n9\nGB-12556\nGrauburgunder\n13.10\nFlasche\n19.00\n2006\n1\n10\nGB-12558\nGrauburgunder\n11.25\nFlasche\n19.00\n2008\n1\n11\nWH-23\nWeißherbst\n16.40\nFlasche\n19.00\n2004\n1\n…\nTabelle: Weinart\nTabelle: Rechnung\nTabelle: RechnungPosition\nRgPos_IdKey\nRgPos_RgIdKey\nRgPos_ArtIdKey\nRgPos_Nr\nRgPos_Mg\nRgPos_EinzelPreis\nRgPos_RabattProzent\nRgPos_MwStSatz\n555434\n2223\n14\n1\n4\n13.80\n0.00\n19.00\n555435\n2223\n19\n2\n12\n17.20\n0.00\n19.00\n555436\n2223\n10\n3\n6\n11.25\n5.00\n19.00\n555437\n2223\n11\n4\n12\n16.40\n5.00\n19.00\n555438\n2224\n14\n1\n8\n13.80\n0.00\n19.00\n555439\n2225\n10\n1\n6\n11.25\n0.00\n19.00\n555450\n2225\n110\n2\n6\n16.40\n0.00\n19.00\n555451\n2225\n12\n3\n12\n15.40\n8.00\n19.00\n555452\n2225\n13\n4\n6\n16.40\n0.00\n19.00\n555453\n2226\n19\n1\n6\n17.20\n0.00\n19.00\n…\na)\nSie sollen eine Kundenliste erstellen, in der alle Kunden ausgegeben werden, welche aus dem PLZ-Gebiet 50800 – 51999 ansässig sind.\nErstellen Sie dazu eine SQL-Anweisung, welche eine Ergebnistabelle entsprechend dem folgenden Beispiel ausgibt.\n(4 Punkte)\nKd_IdKey\nKd_Firma\nKd_Strasse\nKd_PLZ\nKd_Ort\nKd_Nummer\n3\nTraberstübchen\nTraberweg 1\n50889\nKöln\n012205\n6\nRheinkneipe\nAm Rhein 2\n50888\nKöln\n014333\n…\nb)\nSie möchten eine Auflistung mit dem niedrigsten und dem höchsten Artikelpreis sowie die Anzahl der Weine pro Jahrgang sortiert nach\nJahrgang absteigend.\nErstellen Sie dazu eine SQL-Anweisung, welche eine Ergebnistabelle entsprechend dem folgenden Beispiel ausgibt.\n(5 Punkte)\nJahrgang\nNiedrigsterPreis\nHöchsterPreis\nAnzahl der Weine je Jahrgang\n2008\n11.25\n13.80\n2\n2007\n14.00\n14.00\n1\n…\nWA_IdKey\nWA_Weinart\n1\nWeißwein\n2\nRotwein\n3\nRosewein\n4\nSchuamwein\n…\nRg_IdKey\nRg_KdIdKey\nRg_Nummer\nRg_Datum\nRg_ZahlFristTage\n2223\n2\nRG-002249\n2023-05-02\n14\n2224\n3\nRG-002250\n2023-05-02\n14\n2225\n3\nRG-002251\n2023-05-04\n14\n2226\n1\nRG-002252\n2023-05-05\n7\n…\nFortsetzung 4. Aufgabe\nc)\nFälschlicherweise wurden für Rotweine bei allen Kunden anstelle von 12 % Rabatt O % Rabatt berechnet.\nErstellen Sie eine SQL-Anweisung, mit der Sie für alle Rotweine, die im Zeitraum Mai 2023 berechnet wurden, den Rabatt von 0 % auf 12 %\nändern.\n(8 Punkte)\nd)\nErstellen Sie eine SQL-Anweisung mit der Sie den berechneten durchschnittlichen Umsatz je Kunde unabhängig der gewährten Rabatte\nerhalten.\n(8 Punkte)\nBeispiel-Ergebnistabelle:\nKd_IdKey\nKd_Firma\nKd_Strasse\nKd_PLZ\nKd_Ort\nKd_Nummer\nUmsatz\n1\nLikelimo\nMusterstr. 12\n50778\nKöln\n012204\n149.520000\n2\nGasthaus 'Die Perle‘\nPerlenstr. 22\n50778\nKöln\n012201\n128.171250\n999\nGasthaus zum Fass\nFassstraße 3\n99900\nFasshausen\n012203\n0\n…\nLösungshinweise Winter 2022/23 Teil 2 - Entwicklung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\n2.\nAufgabe Lösung\ncalculateFlight(geoPositions: GeoPos[] ) : GeoPos[]\nflight_positions = new GeoPos[geoPositions.length]    // Array der angeflogenen\n// Positionen\nflightPositions[0] = geoPositions[0]                  // Position 0 als Startposition\ncurrentPos = geoPositions[0]\ngeoPositions.remove(0)                        // aus dem Array der noch anzufliegenden Positionen entfernen\nnext = 1                                      // nächster Index in flightPositions\nwhile (geoPositions.length > 0)               // Solange noch Positionen anzufliegen sind\nminDistance = Double.MAX VALUE\nminPos = 0\nfor i = 0 to geoPositions.length -1\ndistance = geoCalculator.getDistance(currentPos, geoPositions[i])\nif distance < minDistance\nminDistance = distance\nminPos = i\nend if\nend for\nflightPositions[next] = geoPositions[minPos]\nnext = next + 1\ncurrentPos = geoPositions[minPos]\ngeoPositions.remove(minPos)\nend while\nreturn flightPositions\nend calculateFlight\n3.\nAufgabe Lösung\na)\nJe Tabelle mit allen Attributen 1 Punkt (5 Punkte) Je Primärschlüssel 1 Punkt (5 Punkte)\nJe Beziehung mit Kardinalität 1 Punkt (4 Punkte) Je Fremdschlüssel 1 Punkt (4 Punkte)\nb)\nHinweis: Rundungsdifferenzen können im Ergebnis berücksichtigt werden.\n20.000.000 Pixel/Bild * 8 Bit/Farbkanal * 3 Farbkanal/Pixel = 480.000.000 Bit/Bild\n480.000.000 Bit/Bild / 8 Bit/Byte = 60.000.000 Byte/Bild / 1.024 / 1.024 /1.024 = 0,05587 GiB/Bild\n0,05587 GiB/Bild* 200 Bilder/Woche* 52 Wochen= 581,4 GiB -> 582 GiB\n4.\nAufgabe Lösung\na)\nSELECT *\nFROM Kunde\nWHERE Kd_PLZ LIKE '508%' OR Kd_PLZ LIKE '509%' OR Kd_PLZ LIKE '51%'\nb)\nSELECT Art_Jahrgang AS Jahrgang\n,MIN(Art_Preis) AS NiedrigsterPreis\n,MAX(Art_Preis) AS HöchsterPreis\n,COUNT(Art_IdKey) AS 'Anzahl der Weine je Jahrgang'\nFROM Artikel\nGROUP BY Art_Jahrgang ORDER BY Jahrgang DESC;\nc)\nUPDATE RechnungPosition SET RgPos_RabattProzent = 12\nFROM RechnungPosition AS RP\nINNER JOIN Rechnung AS R\nON R Rg_IdKey RP.RgPos_RgldKey\nINNER JOIN Artikel AS A\nON A Art_IdKey = RP.RgPos_ArtldKey\nINNER JOIN WeinArt AS WA\nON WA.WA_IdKey - A.Art_WAldKey\nWHERE (Month(RRg_Datum) = 5 AND YEAR(RRg_Datum) 2023)\nAND RP.RgPos_RabattProzent = 0\nAND WA.WA_Weinart = 'Rotwein'.\nd)\nSELECT Kd_IdKey, Kd_Firma. Kd_Strasse Kd_PLZ, Kd_Ort, Kd_Nummer,\n(SELECT AVG(RgPos_Einzelpreis * RgPos_Mg)\nFROM RechnungPosition AS RP\nINNER JOIN Rechnung AS R\nON R Rg_IdKey = RP RgPos_RgldKey\nWHERE Kd_IdKey = R Rg_KdIdKey) AS Umsatz\nFROM Kunde;"}]},{"id":"sommer_2024_teil2","season":"Sommer","year":"2024","teil":2,"title":"Entwicklung und Umsetzung von Algorithmen","label":"AP2 Sommer 2024 – Teil 2","tasks":[{"num":1,"points":25,"content":"a)\nDer Einladungsvorgang zur Aktionärsversammlung soll mithilfe eines UML-Aktivitätsdiagramms dargestellt werden.\n-\nEin Mitarbeiter des Aktionärssekretariats versendet die Einladungen gleichzeitig per Post und über die E-Service-Plattform.\n-\nWenn ein Aktionär einen Zugang zur E-Service-Plattform hat, meldet er sich dort an und kann dabei zwischen virtueller Teilnahme\nund Präsenzteilnahme wählen. Hat der Aktionär keinen E-Service-Zugang, kann er nur in Präsenz teilnehmen und die Anmeldung per\nPost versenden. Diese postalische Anmeldung wird vom Mitarbeiter erfasst. (Der Fall, dass von einem Aktionär keine Anmeldung\nerfolgt, soll ignoriert werden,)\n-\nUnmittelbar nach jeder Online-Anmeldung zur Präsenzteilnahme bzw. Erfassung durch den Mitarbeiter im Aktionärssekretariat wird\ndurch das System ein Platz für den Aktionär reserviert.\n-\nBei virtueller Teilnahme wird kein Platz reserviert.\n-\nNach der Reservierung versendet das System entweder die Platzkarten zusammen mit der Tagesordnung an den Aktionär oder bei\nvirtueller Teilnahme die Zugangsdaten und die Tagessordnung.\nErgänzen Sie das folgende UML-Aktivitätsdiagramm.\n(14 Punkte)\nMitarbeiter\nAktionär\nSystem\nFortsetzung 1. Aufgabe\nb)\nDie Einladungen werden an die Nutzer der E-Service-Plattform per E-Mail als Worddokument im Anhang versendet.\nba) Beschreiben Sie ein mögliches Sicherheitsrisiko, welches sich daraus ergeben kann.\n(2 Punkte)\nbb) Erläutern Sie eine Alternative zu diesem Vorgehen der AMAG Soft AG, die mehr Sicherheit bietet.\n(3 Punkte)\nc)\nDie E-Service-Plattform soll es den Aktionären ermöglichen, komfortabel ihr Passwort zurückzusetzen.\nIn einer Teamsitzung wird vorgeschlagen, eine E-Mail mit einem Link zum Zurücksetzen des Passwortes an die gespeicherte E-Mail-Adresse\nzu versenden.\nca) Erläutern sie eine Schwachstelle dieses Vorschlags.\n(3 Punkte)\ncb) Erläutern sie ein Vorgehen, welches mehr Sicherheit bringt.\n(3 Punkte)‘"},{"num":2,"points":20,"content":"Die Geschäftsleitung möchte Aktiennotierungen nach einem beliebigen Kriterium sortieren können. Daher soll für den Vergleich innerhalb des\nSortieralgorithmus eine Vergleichsfunktion verwendet werden. Es existiert bereits eine Klasse Tageskurs, die Informationen zu einer Aktie bereitstellt.\nAußerdem ist ein Array kurse vorhanden, in dem Objekte vom Typ Tageskurs gespeichert sind.\nKlasse Tageskurs\nTageskurs\n- datum: Date\n- aktienkurs: double\n- daxWert: double\n- prozVAktie: double //prozentuale Veränderung Aktie zum Vortagswert\n- prozVdAX: double //prozentuale Veränderung DAX zum Vortagswert\nFür jedes Attribut gibt es öffentliche get-Methoden.\nAuflistung der daten der Tageskurs-Objekte aus dem Array kurse\ndatum\naktienkurs\ndaxWert\nprozVAktie\nprozVDAX\n15.04.2024\n100\n15000\n0,0300\n0,0500\n16.04.2024\n105\n15100\n0,0500\n0,0067\n17.024.2024\n110\n14900\n0,0476\n-0,0132\n…\na)\nFür die Sortierfunktion sort(Tageskurs[] kurse, Fuction vergleiche): void wird das Fuction-Objekt vergleiche übergeben.\nDie im Function-Objekt vorhandene Funktion kann im Sortieralgorithmus wie folgt aufgerufen werden:\nvergleiche(tageskursA, tageskursB)\nDie Vergleichsfunktion liefert einen Wert > 0 zurück, wenn tageskursB vor tageskursA sortiert werden soll.\nGeben Sie auf der folgenden Seite einen Sortieralgorithmus eigener Wahl im Pseudocode an und nennen Sie den gewählten\nSortieralgorithmus.\n(12 Punkte)\nFortsetzung 2. Aufgabe\nb)\nDie Geschäftsleitung möchte wissen, an wie vielen Tagen der Aktienkurs der AMAG Soft AG „besser“ notiert war als der DAX an diesem\nTag.\nDie prozentualen Veränderungen des Aktienkurses und des DAX-Wertes gegenüber dem Vortag stehen in den Objekten der Klasse\nTageskurs.\nDie Notierung des Aktienkurses wird als „besser“ als die des DAX bezeichnet, wenn diese prozentuale Veränderung des Aktienkurses\ngrößer war als die des DAX.\nDie entsprechenden Daten sind in dem Array kurse vom Typ Tageskurs vorhanden.\nErstellen Sie einen Algorithmus für eine Funktion notierungPlus(Tageskurs[] kurse): Integer, der ermittelt, an wie vielen Tagen die\nprozentuale Veränderung des Aktienkurses „besser“ war als die des DAX und diesen Wert zurückgibt.\n(8 Punkte)\nnotierungPlus(Tageskurs[] kurse): Integer"},{"num":3,"points":25,"content":"Sie sind dem Team zugeordnet, welches sich schwerpunktmäßig mit dem Testen der zukünftigen Software beschäftigt.\naa) Sie diskutieren im Team die Vor- und Nachteile von Whitebox- und Blackbox-Tests.\nBeschreiben Sie zwei Vorteile von Whitebox-Tests gegenüber von Blackbox-Tests.\n(4 Punkte)\nab) Ihr Team möchte verschiedene Regessionstests entwickeln.\nErläutern sie den Zweck von Regressionstests.\n(4 Punkte)\nb)\nBei Whitebox-Tests gibt es verschiedene Metriken, deren Verwendung die Gewinnung der Testdaten beeinflusst. Dazu gehören die\nanweisungs-, die Zweig- und die Pfadüberdeckung, die im folgenden englischen Text beschrieben werden:\nStatement coverage, branch coverage, and path coverage are important white box testing metrics that help ensure that software programs\nare performing reliably, correctly, and efficiently.\nStatement coverage is a measure of the percentage of statements in a program that are executed by a set of tests. In statement coverage,\nthe test data should be chosen such that all statements in the code are executed at least once.\nBranch coverage is a measure of the percentage of branches in a program that are executed by a set of tests. The choice of test data is\nintended to ensure that all percentage of branches of each condition are executed at least once. A full branch coverage automatically\nincludes a full statement coverage.\nPath coverage is a measure of the percentage of paths through a program that are executed by a set of tests. A path is a sequence of\nstatements that starts at the entry point of the program and ends at an exit point. A full path coverage automatically includes a full branches\ncoverage.\nErläutern Sie mithilfe des englischen Textes, nach welchen Kriterien bei den nachfolgenden Metriken die Testdaten gewonnen werden und\nwie die einzelnen Metriken aufeinander aufbauen.\n(12 Punkte)\nAnweisungsüberdeckung:\nZweigüberdeckung:\nPfadüberdeckung:\nFortsetzung 3. Aufgabe\nc)\nGegeben ist folgender Algorithmus:\nvoid login(string name, string password) {\nif (checkCredentials(name, password)) {\nB1\nshowStandardMenu();\nA1\nif (checkPremiumMember()) {\nB2\nshowPremiumMemberMenu();\nA3\n}\nif (checkStaffMember()) {\nB3\nshowStaffMemberMenu();\nA4\n}\n} else {\nshowErrorMessage();\nA2\n}\n}\nNotieren Sie alle Pfade, welche in diesem Algorithmus durchlaufen werden können, um eine vollständige Pfadüberdeckung zu erreichen.\nGeben Sie dazu pro Pfad alle durchlaufenden Bedingungen (B) und Anweisungen (A) in der Reihenfolge ihrer Abarbeitung an.\nBeispiel: 1. B1, A3, A4, B2 …\n(5 Punkte)\n(Hinweis: Das Beispiel stellt keinen möglichen Pfad dar.)\nNummer\nPfad\n1\n2\n3\n4\n5"},{"num":4,"points":30,"content":"Für die Aktionärsversammlung sollen Auswertungen des Aktienkurses vorgelegt werden.\nDie Tabellen in der Anlage: Aktien-Tabellen stehen dafür zur Verfügung.\na)\nDie Aktie mit dem Namen „MTU Aero Engines“ wird nicht mehr gehandelt.\nErstellen Sie eine SQL-Anweisung, welche alle Einträge der Aktie (AK_AktieID: 4) aus der Tabelle AktienKurs entfernt.\n(2 Punkte)\nAnlage Aktien-Tabellen\nTabelle: Aktie\nTabelle: Boerse\nAK_ID\nA_AktienName\nA_WKN\n1\nHannover Rück\n840221\n2\nDeutsche Bank\n514000\n3\nDaimler Truck\nDTROCK\n4\nMTU Aero Engines\nA0D9PT\n5\nMünchner Rück\n843002\n6\nAMAG\n999999\n…\nTabelle: AktienKurs (Ausschnitt der Transaktions-Daten)\nAK_ID\nAK_DatumZeit\nAK_Kurs\nAK_BoerseID\nAK_AktieID\nAK_Anzahl\n10021\n2024-04-19 10:08:00.033\n53.55\n1\n6\n5\n10022\n2024-04-19 10:09:20.110\n54.21\n2\n6\n100\n10023\n2024-04-19 10:09:55.110\n54,19\n1\n6\n150\n10024\n2024-04-19 10:09:55.120\n222,66\n2\n4\n150\n10025\n2024-04-19 10:11:55.120\n53,99\n4\n6\n150\n10026\n2024-04-19 10:12:05.120\n53,98\n3\n6\n70\n10027\n2024-04-19 11:00:01.020\n54,02\n2\n6\n99\n10028\n2024-04-19 11:00:02.033\n54,06\n3\n6\n120\n10029\n2024-04-19 11:00:02.133\n54,00\n2\n6\n250\n…\nb)\nErstellen Sie eine SQL-Anweisung, welche den Minimal-, den Maximal-, den Durchschnittskurs sowie die Anzahl der Transaktionen der\nAMAG-Aktie (AK_AktieID: 6) an den verschiedenen Börsen entsprechend der folgenden Ergebnistabelle ausgibt.\n(8 Punkte)\nB_ID\nB_BoersenName\nKursMin\nKursMax\nKursDurchschitt\nAnzahlTransaktionen\n1\nBörse Frankfurt\n53.55\n54.19\n53.870000\n2434\n2\nStuttgarter Wertpapierbörse\n54.00\n54.21\n54.076666\n3234\n3\nNiedersächsische Börse Hannover\n53.98\n54.06\n54.020000\n2334\n4\nBörse Düsseldorf\n53.99\n53.99\n53.990000\n1223\nc)\nAm Anfang eines neuen Jahres werden alle Daten der Vorjahre aus der Tabelle AktienKurs in die Tabelle AktienKursArchiv verschoben.\nDie Tabelle AktienKursArchiv ist gleich der Tabelle AktienKurs aufgebaut.\nErstellen Sie SQL-Anweisungen, welche die Daten entsprechend der Beschreibung verschieben.\n(8 Punkte)\nB_ID\nB_BoerseName\nB_BoerseKng\n1\nBörse Frankfurt\nFWB\n2\nStuttgarter Wertpapierbörse\nEUWAX\n3\nNiedersächsische Börse Hannover\nBÖAG\n4\nBörse Düsseldorf\nBD\n5\nBörse München\nBM\n6\nTradegate Exchange\nTradegate\n…\nFortsetzung 4. Aufgabe\nd)\nSie möchten für alle Jahre über alle Börsen den Minimal- und den Maximalkurs sowie die Anzahl der Transaktionen im Jahr von der AMAG-\nAktie (AK_AktieID: 6) entsprechend der nachfolgenden Ergebnistabelle erhalten. Die Tabelle soll absteigend nach Jahren sortiert werden.\nDenken Sie daran, dass die Daten der Vorjahre in der Tabelle AktienKursArchiv archiviert wurden.\n(12 Punkte)\nBoersenjahr\nKursMin\nKursMax\nAnzahlTransaktionen\n2024\n53.55\n54.21\n4343\n2023\n48.33\n52.09\n9987\n2022\n48.32\n51.44\n6554\nLösungshinweise Sommer 2024 Teil 2 – Entwickelung und Umsetzung von Algorithmen\n1.\nAufgabe Lösung\na)\nJe Aktivität an der korrekten Stelle 1 Punkt, Je Verzweigung 2 Punkte, Parallelisierung 2 Punkte\nba)\nZ. B. Word-Dokumente aus externen Quellen zu öffnen, birgt ein hohes Sicherheitsrisiko.\nbb)\nZ. B. Einladung direkt im Web-Browser auf der Plattform öffnen, da so keine Manipulation des Dokumentes möglich ist.\nca)\nErwartet wird eine Erläuterung zu Schwachstellen,\nz. B. E-Mail-Link könnte in falsche Hände gelangen.\ncb)\nErwartet wird eine Erläuterung zu einem Vorgehen,\nz. B. eine SMS mit einem Transaktionscode parallel zum Rücksetz-Link versenden, sodass ein 2. Weg benutzt wird, um das Rücksetzen\nabzusichern.\n2.\nAufgabe Lösung\nb)\nBeispielhaft mit bubbleSort:\n// BubbleSort\nsort (Tageskurs[] kurse, Function vergleiche) : void\nfor (i = 0; i < kurse.length – 1; i++)\nfor (j = 0; j < kurse.length – 1 – i; j++)\nif (vergleiche(kurse[j], kurse[j+1]) > 0)\nTageskurs k = kurse[j]\nkurse[j] = kurse[j+1]\nkurse[j+1] = k\nEnd if\nEnd for\nEnd for\nEnd sort\nc)\nnotierungPlus(Tageskurs[] kurse): Integer\ncount: Integer = 0\nfor (i = 0; i < kurse.length; i++)\nif (kurse[i].getProzVAktie() > kurse[i].getProzVDAX() ) count++\nEnd For\nReturn count\nEnd notierungPlus\n3.\nAufgabe Lösung\naa)\n-\nEs können Fehler genauer lokalisiert werden.\n-\nEs werden alle Programmteile getestet, auch solche, welche durch die Anforderungsspezifikation nicht erfasst wurden.\n-\nEs wird eine hohe Testabdeckung des Quellcodes erreicht.\n-\nUnterstützt das Optimieren des Quellcodes\n-\nu. a.\nab)\nRegressionstests sind Tests, mit deren Hilfe sichergestellt werden soll, dass das Hinzufügen von neuem Code, Optimierungen innerhalb\ndes Codes oder das Beheben von Fehlern die vorhandene Funktionalität nicht beeinträchtigt und noch den Anforderungen entspricht.\nb)\nAnweisungsüberdeckung: (4 Punkte)\nDie Anweisungsüberdeckung ist ein Maß für den prozentualen Anteil der Anweisungen in einem Programm, die von einer Reihe von Tests\nausgeführt werden. Bei der Anweisungsüberdeckung sollten die Testdaten so gewählt werden, dass alle Anweisungen im Code mindestens\neinmal ausgeführt werden.\nZweigüberdeckung: (4 Punkte)\nDie Zweigüberdeckung ist ein Maß für den prozentualen Anteil der Verzweigungen in einem Programm, die von einer Reihe von Tests\nausgeführt werden. Durch die Auswahl der Testdaten soll sichergestellt werden, dass alle Verzweigungen jeder Bedingung mindestens\neinmal ausgeführt werden. Eine vollständige Zweigüberdeckung beinhaltet automatisch eine vollständige Anweisungsüberdeckung.\nPfadüberdeckung: (4 Punkte)\nDie Pfadüberdeckung ist ein Maß für den prozentualen Anteil der Pfade in einem Programm, die von einer Reihe von Tests ausgeführt\nwerden. Ein Pfad ist eine Folge von Anweisungen, die am Einstiegspunkt des Programms beginnt und an einem Ausstiegspunkt endet. Eine\nvollständige Pfadüberdeckung beinhaltet automatisch eine vollständige Zweigüberdeckung.\nc)\nc) 5 Punkte\nDie Reihenfolge der Pfade ist beliebig.\n4.\nAufgabe Lösung\na)\nDELETE FROM AktienKurs WHERE AK_AktieID = 4\nb)\nSELECT B.B_ID\n,B.B_BoersenName\n,MIN(AK.AK_Kurs) AS KursMin\n,MAX(AK.AK_Kurs) AS KursMax\n,AVG(AK.AK_Kurs) AS KursDurchschnitt\n,COUNT(AK.AK_ID) AS AnzahlTransaktionen\nFROM Boerse AS B\nINNER JOIN AktienKurs AS AK ON AK.AK_BoerseID = B.B_ID\nWHERE AK.AK_AktieID = 6\nGROUP BY B.B_ID, B.B_BoersenName;\nc)\nINSERT INTO AktienKursArchiv\n(AK_ID, AK_DatumZeit, AK_Kurs, AK_BoerseID, AK_AktieID)\nSELECT AK_ID, AK_DatumZeit, AK_Kurs, AK_BoerseID, AK_AktieID\nFROM AktienKurs\nWHERE YEAR(AK_DatumZeit) < YEAR(TODAY);\nDELETE FROM AktienKurs WHERE YEAR(AK_DatumZeit) < YEAR(TODAY);\nAndere korrekte Lösungen sind auch möglich.\nd)\nSELECT YEAR(AK.AK_DatumZeit) AS Boersenjahr\n,MIN(AK.AK_Kurs) AS KursMin\n,MAX(AK.AK_Kurs) AS KursMax\n,COUNT(AK.AK_ID) AS AnzahlTransaktionen\nFROM AktienKurs AS AK\nWHERE AK.AK_AktieID = 6\nGROUP BY YEAR(AK.AK_DatumZeit)\nUNION ALL\nSELECT YEAR(AKA.AK_DatumZeit)\n,MIN(AKA.AK_Kurs)\n,MAX(AKA.AK_Kurs)\n,COUNT(AKA.AK_ID)\nFROM AktienKursArchiv AS AKA\nWHERE AKA.AK_AktieID = 6\nGROUP BY YEAR(AKA.AK_DatumZeit)\nORDER BY Boersenjahr DESC;"}]}]}